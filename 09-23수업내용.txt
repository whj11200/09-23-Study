

지난내용
( Thread t1 = new Thread(매서드이름)
t1.name = "test"
t1.Start(); 위에 쓰레드(메서드) 직접 실행되는 구간
t1.Abort(); 위의 쓰레드가 될때까지 대기
서버스를 요청 = 클라이언트
서버스를 받음 = 서버
Aws AutoScalling 정책 프론티어
서버 = 로그인서버,데이터 서버

- 컴퍼일러 최적화	

현재 코드를 짤때 Debug 모드로 했지만 나중에 게임을 실제로 배포하고 라이브에 서비스를 하면
Release모드로 바꿔줘야한다. 
Release 모드로 바꿔주면 온갖 자동으로 최적화가 되어서 프로그램이 훨씬 빨라진다.
이렇게 모드를 바꾸면 더 어려워 질 수 가있다.
- 캐시이론
 CPU -> 캐시메모리 -> RAM 
 1) Tempporal Locality
     시간적으로 보면 방금 주문한 테이블에서 추가 주문이 나올 확률이 높다. 
 2) Spacilal Locality
     공간적으로 보면 방금 주문한 사람 근처에 있는 사람이 추가 주문을 할 확률이 높다.
     방금 주문한 사람과 합석 하고 있는 사람들의 주문 목록도 메모 해 놓으면 
     편하지 않을까?
- 메모리 베리어
   cpu 가 성능을 좋게 하기위해 최적화를 거쳐 순서에 맞지 않게 실행시키는 결과를 초래할 수 있기 
   때문에 필수적이다. 이런 메모리 연산(load/store)의 재배치는 single 쓰레드로 실행할 때는 알아차리기 
   어렵지만, 제대로 관리되지않는 한 병행적으로 작도오디는 프로그램과 디바이스 드라이버에서
   예상할 수 없는 결과 초래하기 때문에 싱글 쓰레드에서는 하드웨어가 명령어 통합성을 강제하기 떄문에
   문제가 되지않는다.

원자성이란?
더 이상 쪼개질 수 없는 성질을 얘기하며
하나로 이루어져 여럿으로 나뉠 수 없는 연산에 대해 atomic하다고 표현합니다.

경쟁 상태를 피하기 위해서는 공유 자원에 대한 처리 혹은 연산을 atomic하게 해야함

Interlocked 클래스는 성능적으로 문제점을 야기 할 수 있다.

원자성을 보장하기 위해 하드웨어 레벨에서 작동하므로 다른 일반 연산보다
더 많은 오버레드 발생
여러 스레드가 동일한 자원에 동시에 
엑세스 하려고 할때 경합이 발생할 수 있음
이런 경합 문제는 스레드들이 자원을 기다리며
시간을 낭비하게 만들고 전체 프로그램의 성을 저하시킴